# Database connection
# Local dev uses a local SQLite file. No auth token needed.
# For production (Vercel/Turso), set to libsql:// URL and provide auth token.
TURSO_DATABASE_URL=file:prisma/dev.db
# TURSO_AUTH_TOKEN=  # Only needed for remote Turso databases
DATABASE_URL=file:./prisma/dev.db  # Used by Prisma CLI (migrations, db push)

# NextAuth secret for JWT signing (generate with: openssl rand -base64 32)
AUTH_SECRET=

# Workspace Oz API key (used to authenticate calls to /api/v1/* from SDKs and other clients).
OZ_API_KEY=

# Optional: Oz Agent API base URL (must include /api/v1).
# Defaults to http://localhost:3000/api/v1 in the vendored SDKs.
# OZ_API_BASE_URL=http://localhost:3000/api/v1

# Optional: Base URL for internal API calls (defaults to http://localhost:3000)
# NEXT_PUBLIC_APP_URL=http://localhost:3000

# Environment ID for running agents (implementation-defined by your control plane).
OZ_ENVIRONMENT_ID=

# Runner mode: local (default) runs providers directly from the Next.js server.
# remote calls an Oz-compatible agent API (Option 2).
OZ_RUNNER_MODE=local

# Local runner provider config (OpenAI-compatible by default).
# You can either configure a single default provider:
# OZ_PROVIDER_BASE_URL=http://localhost:11434/v1
# OZ_PROVIDER_API_KEY=
# OZ_PROVIDER_MODEL=gpt-4.1-mini
#
# Or configure per-harness providers:
# OZ_PROVIDER_CLAUDE_BASE_URL=...
# OZ_PROVIDER_CLAUDE_API_KEY=...
# OZ_PROVIDER_CLAUDE_MODEL=...
# OZ_PROVIDER_CLAUDE_TYPE=anthropic
# Or, to use a subscription-backed CLI instead of an API:
# OZ_PROVIDER_CLAUDE_TYPE=cli
# OZ_PROVIDER_CLAUDE_CLI_CMD=claude
# OZ_PROVIDER_CLAUDE_CLI_ARGS=["-p"]  # Claude Code: claude -p "<prompt>"
# OZ_PROVIDER_CLAUDE_CLI_PROMPT_MODE=arg
# OZ_PROVIDER_CODEX_BASE_URL=...
# OZ_PROVIDER_CODEX_API_KEY=...
# OZ_PROVIDER_CODEX_MODEL=...
# OZ_PROVIDER_CODEX_TYPE=openai_compatible
# Or CLI:
# OZ_PROVIDER_CODEX_TYPE=cli
# OZ_PROVIDER_CODEX_CLI_CMD=codex
# OZ_PROVIDER_CODEX_CLI_ARGS=["exec"]  # Codex CLI: codex exec "<prompt>"
# OZ_PROVIDER_CODEX_CLI_PROMPT_MODE=arg
# OZ_PROVIDER_GLM_BASE_URL=...
# OZ_PROVIDER_GLM_API_KEY=...
# OZ_PROVIDER_GLM_MODEL=...
# OZ_PROVIDER_KIMI_BASE_URL=...
# OZ_PROVIDER_KIMI_API_KEY=...
# OZ_PROVIDER_KIMI_MODEL=...
#
# Optional per-provider quota (rolling window by "messages", used for routing/fallback):
# OZ_PROVIDER_CLAUDE_MSG_LIMIT=100
# OZ_PROVIDER_CLAUDE_WINDOW_SECONDS=18000
# OZ_PROVIDER_CODEX_MSG_LIMIT=40
# OZ_PROVIDER_CODEX_WINDOW_SECONDS=10800
#
# Fallback order when a provider is saturated or rate-limited:
# OZ_PROVIDER_FALLBACK_ORDER=glm,kimi,custom
# OZ_QUEUE_ON_SATURATION=true
# OZ_QUEUE_MAX_WAIT_SECONDS=300

# Agent Callback URL - Required for Oz agents to send responses back
# The agent runtime needs a publicly accessible URL to POST its response (if callbacks are used).
#
# Use ngrok to expose your local server:
#   1. Install ngrok: brew install ngrok
#   2. Run: ngrok http 3000
#   3. Copy the https URL and set it here
AGENT_CALLBACK_URL=

# Agent API Key - Used to authenticate agent callbacks and internal agent endpoints.
# Callers must send: X-Agent-Key: $AGENT_API_KEY
# Generate with: openssl rand -base64 32
AGENT_API_KEY=

# Optional: make key API routes await Redis XADD instead of fire-and-forget.
# OZ_REDIS_EVENTS_DURABLE=1
#
# Optional: fail requests when Redis is configured but event persistence fails.
# (Strict implies durable.)
# OZ_REDIS_EVENTS_STRICT=1

# Optional: best-effort sweeper to reset agents stuck in "running" due to serverless timeouts.
# OZ_STALE_AGENT_SWEEP_MS=300000
